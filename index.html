<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>모두의 업무노트</title>
  

  </a>
</div>
  <link rel="icon" href="./favicon.ico">
  <style>
    :root{
      --bg:#f6f7f8; --card:#ffffff; --text:#111; --muted:#667084; --border:#e5e7eb;
      --primary:#2563eb; --danger:#dc2626; --ring:#93c5fd;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .container{
      max-width:1100px;
      margin:0 auto;
      padding:24px 20px;
      box-sizing:border-box;
    }
    h1{margin:0 0 4px 0;font-size:28px}
    p.lead{margin:0 0 16px 0;color:var(--muted);font-size:14px}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:end;justify-content:space-between;margin-bottom:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .pill{display:flex;align-items:center;gap:8px;border:1px solid var(--border);background:var(--card);padding:8px 12px;border-radius:999px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    label.small{font-size:12px;text-transform:uppercase;color:var(--muted);}
    input[type="date"],input[type="time"],input[type="text"],textarea,select{
      border:1px solid var(--border);border-radius:12px;padding:10px 12px;font-size:15px;background:#fff;outline:none;min-height:40px
    }
    input[type="text"]{width:100%}
    textarea{width:100%;resize:vertical}
    button{border:0;border-radius:14px;background:var(--primary);color:#fff;padding:10px 14px;font-size:15px;cursor:pointer}
    button.secondary{background:#eef2ff;color:#3730a3}
    button.ghost{background:#fff;color:#111;border:1px solid var(--border)}
    button.danger{background:var(--danger)}
    button:focus{outline:2px solid var(--ring);outline-offset:2px}

    /* CSV Import/Export buttons: white background */
    #loadCsvBtn,
    #saveCsvBtn,
    #loadCsvBtn2,
    #saveCsvBtn2,
    #importBtn,
    #exportBtn {
      background-color: white !important;
      color: black;
      border: 1px solid #ccc;
    }
    .card{background:var(--card);border:1px solid var(--border);border-radius:20px;box-shadow:0 1px 2px rgba(0,0,0,.05);padding:16px}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:12px}
    .col-1{grid-column:span 1}.col-2{grid-column:span 2}.col-3{grid-column:span 3}.col-4{grid-column:span 4}.col-5{grid-column:span 5}
    .col-6{grid-column:span 6}.col-7{grid-column:span 7}.col-8{grid-column:span 8}.col-9{grid-column:span 9}.col-10{grid-column:span 10}.col-12{grid-column:span 12}
    @media (max-width:900px){.grid{grid-template-columns:repeat(6,1fr)} .col-md-12{grid-column:span 6}}
    @media (max-width:640px){.grid{grid-template-columns:repeat(4,1fr)} .col-sm-12{grid-column:span 4} input[type="text"]{width:160px}}
    .badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:3px 8px;
      font-size:13px;
      color:#374151;
      background:#fff;
      white-space:nowrap;
      margin-right:10px;
      flex-shrink:0;
    }
    /* Summary bar for badges and search */
    .summary {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 10px;
      flex-wrap: nowrap;
      width: 100%;
    }
    .summary input[type="search"], .summary input[type="text"] {
      flex-grow: 1;
      min-width: 180px;
      max-width: 300px;
    }
    .footer-note{
      padding-left:40px;
      padding-right:40px;
      box-sizing:border-box;
    }
    .badge.secondary{background:#f3f4f6;border-color:#e5e7eb}
    .muted{color:var(--muted)}
    .spacer{height:8px}
    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-left:20px;
      margin-right:20px;
      /* Responsive: avoid horizontal scroll on small screens */
      max-width:100%;
      box-sizing:border-box;
    }
    .list .selected {
      padding-left: 40px;
      padding-right: 40px;
      box-sizing: border-box;
    }
    .item{display:flex;gap:12px;align-items:flex-start}
    .item .left{flex:1}
    .item.done{opacity:1;background:#e5e7eb;} .item.done h3{color:#374151;} .item.done p{color:#4b5563;}
    .chips{display:flex;flex-wrap:wrap;gap:6px}
    .right-actions{display:flex;gap:6px;flex-wrap:wrap}
    .stats{display:flex;gap:6px;align-items:center}
    .empty{color:var(--muted);padding:16px}
    /* Modal */
.modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center; z-index:9999;
}
.modal-backdrop.show{display:flex;}
.modal{
  width:min(860px, 92vw);
  background:var(--card);
  border:1px solid var(--border);
  border-radius:20px;
  box-shadow:0 20px 40px rgba(0,0,0,.2);
  padding:16px;
  animation:pop .12s ease-out;
}
.modal-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px;
}
.modal-header h2{font-size:18px; margin:0;}
.modal-close{
  background:#fff; color:#111; border:1px solid var(--border);
  border-radius:10px; padding:6px 10px; cursor:pointer;
}
    @keyframes pop{from{transform:translateY(6px); opacity:.8} to{transform:none; opacity:1}}
    .view-switch { display:flex; gap:6px; align-items:center; margin:0 0 8px 0; }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 12px;
      /* wider cells → allow horizontal scroll on smaller screens */
      min-width: 980px;
    }
    .calendar-header{
      display:grid;
      grid-template-columns:repeat(7,1fr);
      gap:8px;
      margin-bottom:8px;
      font-size:12px;
      color:var(--muted);
      text-align:center;
    }
    .calendar-header div{
      padding:4px 0;
    }
    .calendar-cell{
      background:#fff;
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      min-height:260px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .calendar-cell .cell-date{ font-size:12px; color:var(--muted); }
    /* titles area inside week/month cells */
    .calendar-titles{
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
      border-top: 1px dashed var(--border);
      margin-top: 6px;
      padding-top: 6px;
    }
    .calendar-titles p{
      margin: 6px 0 0 0;
      font-size: 13px;
      line-height: 1.25;
      word-break: break-word;
    }

    /* allow horizontal scroll for calendar on narrow screens */
    #calendarView{
      overflow-x: auto;
      padding-bottom: 8px;
    }
    .calendar-chip{ display:inline-flex; gap:6px; flex-wrap:wrap; }
    .calendar-chip .badge{ margin-right:0; }
    .hidden{ display:none !important; }

    /* Highlight today's date in week/month view */
    .calendar-cell.today{
      border:2px solid var(--primary);
    }
    .calendar-cell.holiday{
      background:#fef2f2;
      border-color:#fecaca;
    }
    .calendar-cell .cell-date .holiday-label{
      display:inline-flex;
      align-items:center;
      margin-left:4px;
      padding:1px 6px;
      border-radius:999px;
      background:#fee2e2;
      color:#b91c1c;
      font-size:11px;
      font-weight:500;
      white-space:nowrap;
    }
    /* Today + holiday badge (일간 상단) */
    #todayHoliday{
      align-items:center;
      justify-content:center;
    }
  </style>
</head>
<body>
  <div class="container">
    <div>
      <h1 style="display:flex;align-items:center;gap:10px;">
  <img src="./logo.png" alt="logo" width="40" height="40" style="border-radius:8px;object-fit:cover;">

<div style="display:flex; align-items:center; justify-content:flex-end; gap:10px; width:100%;">
  <h1 id="title" style="margin:0; margin-right:auto;">모두의업무노트</h1>
  <button id="tripLinkBtn" type="button">모두의출장</button>
</div>
</h1>

      <p class="lead">단순하지만 강력한 일과 기록 · 로컬 저장</p>
    </div>

    <div class="toolbar" style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; justify-content: space-between;">
      <div class="left-group" style="display: flex; align-items: center; margin-right: auto;">
        <div class="pill" style="display: flex; align-items: center; gap: 8px;">
          <label class="small">Date</label>
          <input id="dateInput" type="date"/>
        </div>
      </div>
      <div class="right-group" style="display: flex; align-items: center; gap: 8px; margin-left: auto;">
        <div>
          <button id="importBtn">CSV가져오기</button>
        </div>
        <div>
          <button id="exportBtn">CSV내보내기</button>
        </div>
        <div>
          <button id="openModalBtn">새 업무 등록</button>
        </div>
      </div>
    </div>

      <div class="summary" style="display:flex; align-items:center; flex-wrap:nowrap; gap:6px;">
        <div id="topPeriodNav" style="display:flex; gap:4px; align-items:center;">
          <button id="prevPeriodBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">◀ 이전</button>
          <button id="todayBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">오늘</button>
          <button id="nextPeriodBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">다음 ▶</button>
        </div>
        <span class="muted">오늘:</span>
        <span id="todayHoliday" class="badge secondary" style="display:none;font-size:12px;"></span>
        <span class="badge" id="statTotal" style="font-size:12px;">총 0</span>
        <span class="badge secondary" id="statDone" style="font-size:12px;">완료 0</span>
        <span class="badge" id="statOpen" style="font-size:12px;">미완료 0</span>
        <input id="queryInput" type="text" placeholder="검색 (제목/메모/태그)" style="flex:1; min-width:180px; height:24px; font-size:12px;"/>
        <select id="filterSelect" style="height:24px; font-size:12px;">
          <option value="all">전체</option>
          <option value="open">미완료</option>
          <option value="done">완료</option>
        </select>
        <div class="view-switch" id="viewSwitchRow" style="display:flex; gap:4px; align-items:center; margin-left:auto;">
          <button id="viewDayBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">일간</button>
          <button id="viewWeekBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">주간</button>
          <button id="viewMonthBtn" class="ghost small" type="button" style="padding:6px 10px; font-size:17px;">월간</button>
        </div>
      </div>
    </div>

    <!-- Registration Modal -->
<div id="addModal" class="modal-backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-header">
      <h2 id="modalTitle">업무 등록</h2>
      <button class="modal-close" id="closeModalBtn" type="button">닫기</button>
    </div>
    <div class="grid">
      <div class="col-6 col-sm-12">
        <label>제목</label>
        <input id="titleInput" type="text" placeholder="예: 주간 보고서 취합"/>
      </div>
      <div class="col-6 col-sm-12">
        <label>메모</label>
        <textarea id="memoInput" rows="1" style="min-height:40px; overflow:hidden; resize:none;" placeholder="세부 내용, 링크 등"></textarea>
      </div>
      <div class="col-2">
        <label>시작</label>
        <input id="startInput" type="time"/>
      </div>
      <div class="col-2">
        <label>종료</label>
        <input id="endInput" type="time"/>
      </div>
      <div class="col-1">
        <label>소요</label>
        <div id="durationBox" class="badge" style="height:40px;align-items:center">-</div>
      </div>
      <!-- 기간 설정 입력 필드 삭제됨 -->
      <div class="col-2">
        <label>우선순위</label>
        <select id="prioritySelect">
          <option value="1">1</option><option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option><option value="5">5</option>
        </select>
      </div>
      <div class="col-2">
        <label>중요도(★)</label>
        <select id="importanceSelect">
          <option value="1">★</option><option value="2">★★</option>
          <option value="3" selected>★★★</option>
          <option value="4">★★★★</option><option value="5">★★★★★</option>
        </select>
      </div>
      <div class="col-6 col-sm-12">
        <label>태그</label>
        <input id="tagsInput" type="text" placeholder="쉼표로 구분 (예: 회의, 결재, 구매)"/>
      </div>
    <!-- 반복 요일 선택 항목 제거됨 -->
        <!-- 새 필드 추가 -->
        <div class="col-12 col-sm-12">
          <label>등록 날짜</label>
          <input id="regDateInput" type="date"/>
        </div>
        <div class="col-6 col-sm-12">
          <label>종료 날짜</label>
          <input id="repeatEndInput" type="date"/>
        </div>
        <div class="col-6 col-sm-12">
          <label>반복</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <label style="display:flex; align-items:center; gap:4px;"><input id="repeatWeekly" type="checkbox"/> 매주 반복</label>
            <label style="display:flex; align-items:center; gap:4px;"><input id="repeatMonthly" type="checkbox"/> 매월 반복</label>
          </div>
        </div>
        <div class="col-12" style="display:flex;justify-content:end; gap:8px;">
        <button id="cancelBtn" class="ghost" type="button">취소</button>
        <button id="addBtn2" type="button">등록</button>
      </div>
    </div>
  </div>
</div>
        </div>
      </div>
    </div>

    <div class="spacer"></div>

    <div id="list" class="list"></div>
    <div id="calendarView" class="hidden">
      <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:8px;">
        <p id="periodTitle" class="muted" style="margin:0;"></p>
      </div>
      <div class="calendar-header">
        <div>일</div>
        <div>월</div>
        <div>화</div>
        <div>수</div>
        <div>목</div>
        <div>금</div>
        <div>토</div>
      </div>
      <div id="calendarGrid" class="calendar-grid"></div>
    </div>

    <div class="spacer"></div>

    <div class="row" style="justify-content:space-between">
      <p class="muted footer-note">데이터는 브라우저에만 저장됩니다. (개별 PC · 보안 용이)          만든이 : 모두의출장 정선우</p>
      <p class="muted footer-note" style="font-size:13px;color:#666;">
        ⚠️ 브라우저 캐시 삭제 시 <strong>‘쿠키 및 사이트 데이터’</strong>를 함께 지우면 업무노트가 사라질 수 있습니다.<br>
        정기적으로 <strong>내보내기(백업)</strong> 기능을 이용해 데이터를 저장해주세요.
      </p>
      <div class="row">
        <!-- <button id="saveCsvBtn2" class="ghost">CSV 내보내기</button>
        <button id="loadCsvBtn2" class="ghost">CSV 가져오기</button> -->
      </div>
    </div>
    <input id="fileInput" type="file" accept=".csv" style="display:none" />
  </div>

  <script>
  (function(){
    const STORAGE_KEY = "worklog_offline_v1";
    // 한국 공휴일 설정 (양력 기준 + 필요 시 개별 날짜 추가)
    const FIXED_HOLIDAYS = {
      "01-01": "신정",
      "03-01": "삼일절",
      "05-05": "어린이날",
      "06-06": "현충일",
      "08-15": "광복절",
      "10-03": "개천절",
      "10-09": "한글날",
      "12-25": "성탄절"
    };
    // 음력 기반 설날·추석·부처님오신날 등은 연도별로 직접 추가하는 용도
    // 연도별로 묶어서 한 눈에 보기 좋게 정리합니다.
    const SPECIAL_HOLIDAYS = {
      // === 2025년 (예시: 이미 알고 있는 날짜) ===
      "2025-01-27": "설날 연휴",
      "2025-01-28": "설날",
      "2025-01-29": "설날 연휴",
      "2025-05-06": "대체공휴일(어린이날)",
      "2025-10-05": "추석 연휴",
      "2025-10-06": "추석",
      "2025-10-07": "추석 연휴",

      // === 2026년 ===
      "2026-02-16": "설날 연휴",
      "2026-02-17": "설날",
      "2026-02-18": "설날 연휴",
      "2026-03-02": "대체공휴일(삼일절)",
      "2026-05-24": "부처님오신날",
      "2026-05-25": "대체공휴일(부처님오신날)",
      "2026-08-17": "대체공휴일(광복절)",
      "2026-09-24": "추석 연휴",
      "2026-09-25": "추석",
      "2026-09-26": "추석 연휴",
      "2026-10-05": "대체공휴일(개천절)",

      // === 2027년 ===
      "2027-02-06": "설날 연휴",
      "2027-02-07": "설날",
      "2027-02-08": "설날 연휴",
      "2027-02-09": "대체공휴일(설날)",
      "2027-05-13": "부처님오신날",
      "2027-06-07": "대체공휴일(현충일)",
      "2027-08-16": "대체공휴일(광복절)",
      "2027-09-14": "추석 연휴",
      "2027-09-15": "추석",
      "2027-09-16": "추석 연휴",
      "2027-10-04": "대체공휴일(개천절)",

      // === 2028년 ===
      "2028-01-26": "설날 연휴",
      "2028-01-27": "설날",
      "2028-01-28": "설날 연휴",
      "2028-05-02": "부처님오신날",
      "2028-10-02": "추석 연휴",
      "2028-10-03": "추석",
      "2028-10-04": "추석 연휴",
      "2028-10-05": "대체공휴일(추석)",

      // === 2029년 ===
      // TODO: 2029년 설날/추석/부처님오신날 및 대체공휴일 날짜를 확정해서 아래에 추가하세요.
      // 예)
      "2029-02-12": "설날 연휴",
      "2029-02-13": "설날",
      "2029-02-14": "설날 연휴",
      "2029-05-20": "부처님오신날",
      "2029-05-21": "부처님오신날 대체공휴일",
      "2029-09-21": "추석 연휴",
      "2029-09-22": "추석",
      "2029-09-23": "추석 연휴",
      "2029-09-24": "추석 대체공휴일",

      // === 2030년 ===
      "2030-02-02": "설날 연휴",
      "2030-02-03": "설날",
      "2030-02-04": "설날 연휴",
      "2030-03-04": "대체공휴일(삼일절)",
      "2030-05-06": "대체공휴일(어린이날)",
      "2030-05-09": "부처님오신날",
      "2030-09-11": "추석 연휴",
      "2030-09-12": "추석",
      "2030-09-13": "추석 연휴",
      "2030-10-04": "대체공휴일(개천절)",

      // === 2031년 ===
      "2031-01-22": "설날 연휴",
      "2031-01-23": "설날",
      "2031-01-24": "설날 연휴",
      "2031-01-27": "대체공휴일(설날)",
      "2031-05-28": "부처님오신날",
      "2031-05-29": "대체공휴일(부처님오신날)",
      "2031-06-09": "대체공휴일(현충일)",
      "2031-08-18": "대체공휴일(광복절)",
      "2031-10-06": "추석 연휴",
      "2031-10-07": "추석",
      "2031-10-08": "추석 연휴",
      "2031-10-09": "대체공휴일(추석)",
      "2031-10-10": "대체공휴일(한글날)",

      // === 2032년 ===
      "2032-02-10": "설날 연휴",
      "2032-02-11": "설날",
      "2032-02-12": "설날 연휴",
      "2032-05-16": "부처님오신날",
      "2032-05-17": "대체공휴일(부처님오신날)",
      "2032-08-16": "대체공휴일(광복절)",
      "2032-09-18": "추석 연휴",
      "2032-09-19": "추석",
      "2032-09-20": "추석 연휴",
      "2032-09-21": "대체공휴일(추석)",
      "2032-10-04": "대체공휴일(개천절)",
      "2032-10-11": "대체공휴일(한글날)",
      "2032-12-27": "대체공휴일(성탄절)"
    }

      // === 필요 시 2024, 2028년 이후 공휴일을 아래에 계속 추가하세요. ===
      // 예)
      // "2024-02-09": "설날 연휴",
      // "2024-02-10": "설날",
      // "2024-02-11": "설날 연휴",
      // "2024-09-16": "추석 연휴",
      // "2024-09-17": "추석",
      // "2024-09-18": "추석 연휴",
      // ...
    
    function getHolidayLabel(dateStr){
      if(!dateStr) return "";
      // 먼저 연도별 개별 지정 공휴일 확인
      if (Object.prototype.hasOwnProperty.call(SPECIAL_HOLIDAYS, dateStr)) {
        return SPECIAL_HOLIDAYS[dateStr];
      }
      // 고정 양력 공휴일 (월-일 기준)
      const md = dateStr.slice(5);
      return FIXED_HOLIDAYS[md] || "";
    }
    // 기간 설정 입력 필드 삭제됨
    const VIEW_MODES = { DAY:'day', WEEK:'week', MONTH:'month' };
    let viewMode = VIEW_MODES.DAY;
    const CARRY_KEY = "worklog_last_carry_date";
    let editingGid = null; // 수정 모드 그룹 id

    // 기간 설정 관련 함수 제거됨

    const dateInput = document.getElementById('dateInput');
// 기본 날짜: 오늘로 설정 + 빠른등록 시작일 동기화
try {
  if (!dateInput.value) dateInput.value = toYYYYMMDD();
  const sdi0 = document.getElementById('startDateInput');
  if (sdi0 && !sdi0.value) sdi0.value = dateInput.value;
} catch(e) {}

    const titleInput = document.getElementById('titleInput');
    const memoInput = document.getElementById('memoInput');
    const startDateInput = document.getElementById('startDateInput');
    const endDateInput = document.getElementById('endDateInput');
    const startInput = document.getElementById('startInput');
    const endInput = document.getElementById('endInput');
    const durationBox = document.getElementById('durationBox');
    const prioritySelect = document.getElementById('prioritySelect');
    const importanceSelect = document.getElementById('importanceSelect');
    const tagsInput = document.getElementById('tagsInput');
    const regDateInput = document.getElementById('regDateInput');
    const repeatWeekly = document.getElementById('repeatWeekly');
    const repeatMonthly = document.getElementById('repeatMonthly');
    const repeatEndInput = document.getElementById('repeatEndInput');
    // removed top addBtn
    const addBtn2 = document.getElementById('addBtn2');
    const listEl = document.getElementById('list');
    const queryInput = document.getElementById('queryInput');
    const filterSelect = document.getElementById('filterSelect');
    try{ filterSelect.value = 'open'; }catch(e){}
    const saveCsvBtn = document.getElementById('saveCsvBtn');
    const saveCsvBtn2 = document.getElementById('saveCsvBtn2');
    const loadCsvBtn = document.getElementById('loadCsvBtn');
    const loadCsvBtn2 = document.getElementById('loadCsvBtn2');
    const fileInput = document.getElementById('fileInput');
    const statTotal = document.getElementById('statTotal');
    const statDone = document.getElementById('statDone');
    const statOpen = document.getElementById('statOpen');
    const todayHolidayEl = document.getElementById('todayHoliday');
    const tripLinkBtn = document.getElementById('tripLinkBtn');
    if (tripLinkBtn) {
      tripLinkBtn.addEventListener('click', () => {
        window.open('https://xn--hu1b83jpzl2iao8w.kr/', '_blank');
      });
    }

    // === Modal open/close wiring for "새 업무 등록" ===
    const addModal = document.getElementById('addModal');
    const openModalBtn = document.getElementById('openModalBtn');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    function openAddModal(g=null){
      if(!addModal) return;
      const isEdit = !!g;
      editingGid = isEdit ? g.gid : null;
      try {
        if (isEdit){
          const any = g.items[0];
          titleInput.value = g.title || '';
          memoInput.value = g.memo || '';
          memoInput.style.height = '40px';
          startInput.value = g.repStart || '';
          endInput.value = g.repEnd || '';
          durationBox.textContent = calcDuration(startInput.value, endInput.value) || "-";
          startDateInput.value = g.minDate || dateInput.value || toYYYYMMDD();
          endDateInput.value = g.maxDate || g.minDate || '';
          prioritySelect.value = String(g.priority ?? 3);
          importanceSelect.value = String(g.importance ?? 3);
          tagsInput.value = (any && any.tags) ? any.tags : '';
          if (regDateInput) regDateInput.value = (g.rangeStart || g.minDate || dateInput.value || toYYYYMMDD());
          // set the repeat end date (repeatUntil) for editing
          if (repeatEndInput) {
            let endVal = '';
            try {
              const anyIt = (g.items && g.items[0]) ? g.items[0] : null;
              endVal = (anyIt && anyIt.repeatUntil) ? anyIt.repeatUntil : '';
            } catch(e){}
            // if nothing stored, fallback to the group's rangeEnd (maxDate)
            if (!endVal) {
              endVal = g.maxDate || '';
            }
            repeatEndInput.value = endVal;
          }
          if (repeatWeekly) repeatWeekly.checked = ((g.items && g.items[0] && g.items[0].repeat) === 'weekly');
          if (repeatMonthly) repeatMonthly.checked = ((g.items && g.items[0] && g.items[0].repeat) === 'monthly');
        }else{
          titleInput.value = '';
          memoInput.value = '';
          memoInput.style.height = '40px';
          startInput.value = '';
          endInput.value = '';
          durationBox.textContent = '-';
          startDateInput.value = dateInput.value || toYYYYMMDD();
          endDateInput.value = '';
          prioritySelect.value = '3';
          importanceSelect.value = '3';
          tagsInput.value = '';
          // Reset registration date to empty for new entries
          if (regDateInput) regDateInput.value = '';
          if (repeatEndInput) repeatEndInput.value = '';
          if (repeatWeekly) repeatWeekly.checked = false;
          if (repeatMonthly) repeatMonthly.checked = false;
        }
      } catch(e) {}
      document.getElementById('modalTitle').textContent = isEdit ? '업무 수정' : '업무 등록';
      addBtn2.textContent = isEdit ? '저장' : '등록';
      addModal.classList.add('show');
      addModal.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';
      setTimeout(()=> titleInput && titleInput.focus(), 0);
    }
    function closeAddModal(){
      if(!addModal) return;
      addModal.classList.remove('show');
      addModal.setAttribute('aria-hidden','true');
      document.body.style.overflow = '';
      // Ensure date-related fields are cleared whenever the modal closes
      try {
        if (regDateInput) regDateInput.value = '';
        if (repeatEndInput) repeatEndInput.value = '';
        if (repeatWeekly) repeatWeekly.checked = false;
        if (repeatMonthly) repeatMonthly.checked = false;
      } catch (e) {}
    }

    if (openModalBtn) openModalBtn.addEventListener('click', ()=> openAddModal(null));
    if (closeModalBtn) closeModalBtn.addEventListener('click', closeAddModal);
    if (cancelBtn) cancelBtn.addEventListener('click', closeAddModal);
    // close when clicking the dark backdrop (outside the dialog)
    if (addModal) addModal.addEventListener('click', (e)=>{ if(e.target === addModal) closeAddModal(); });
    // close on Escape key
    document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeAddModal(); });

    function toYYYYMMDD(d = new Date()){
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${yyyy}-${mm}-${dd}`;
    }
    dateInput.value = toYYYYMMDD();
    try { if(startDateInput) startDateInput.value = dateInput.value; } catch(e) {}

    function load(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      }catch(e){ return []; }
    }
    function save(items){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(items)); }catch(e){}
    }
    function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }

    let items = load();

    // migration: default priority/importance
    items = items.map(it => ({
      ...it,
      priority: it.priority ?? 3,
      importance: it.importance ?? 3,
    }));
    save(items);
    try {
  const todayStr = toYYYYMMDD();
  let changed = false;
  // 오늘 이전 날짜의 미완료 항목을 모두 오늘로 이동
  items = items.map(it => {
    if (it.date && it.date < todayStr && !it.done) {
      changed = true;
      return { ...it, date: todayStr };
    }
    return it;
  });
  if (changed) save(items);
  // 마지막 이월 날짜를 오늘로 기록
  localStorage.setItem(CARRY_KEY, todayStr);
} catch (e) {}
    function parseYMD(s){ const [y,m,d]=s.split('-').map(Number); return new Date(y, m-1, d); }
    function fmtYMD(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const da=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${da}`; }
    function startOfWeek(d){ const x=new Date(d); const day=x.getDay(); x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x; } // 일요일 시작
    function endOfWeek(d){ const s=startOfWeek(d); const e=new Date(s); e.setDate(s.getDate()+6); return e; }

    let calendarAnchor = new Date();

    // --- Shared config for week/month cells ---
    const WEEK_MAX_TITLES = 999;   // 주간: 최대 제목 수 (셀 내부 스크롤로 전부 표시)
    const MONTH_MAX_TITLES = 999;  // 월간: 최대 제목 수 (셀 내부 스크롤로 전부 표시)

    // 일간 리스트와 동일한 정렬 우선순위 (미완료 우선 → 우선순위↑ → 중요도↓ → 시작시간↑ → 생성일↓)
    function compareItems(a, b){
      const ad = !!a.done, bd = !!b.done;
      if (ad !== bd) return Number(ad) - Number(bd); // not-done first
      const ap = Number(a.priority ?? 999), bp = Number(b.priority ?? 999);
      if (ap !== bp) return ap - bp;
      const ai = Number(a.importance ?? 0), bi = Number(b.importance ?? 0);
      if (ai !== bi) return bi - ai;
      const as = a.start || "", bs = b.start || "";
      if (as !== bs) return as.localeCompare(bs);
      return (Number(b.createdAt||0) - Number(a.createdAt||0));
    }

    // 주간/월간용 필터 + 검색 매칭 함수
    function matchesWeeklyMonthly(it){
      const q = (queryInput.value || "").toLowerCase().trim();
      const filter = filterSelect.value;

      // 상태 필터(전체/미완료/완료)
      if (filter === 'open' && it.done) return false;
      if (filter === 'done' && !it.done) return false;

      // 검색어 필터(제목/메모/태그)
      if (!q) return true;
      const hay = `${it.title || ''} ${it.memo || ''} ${it.tags || ''}`.toLowerCase();
      return hay.includes(q);
    }

    // 현재 보기 모드에 맞춰 다시 그리는 헬퍼
    function renderCurrent(){
      if (viewMode === VIEW_MODES.DAY) render();
      else if (viewMode === VIEW_MODES.WEEK) renderCalendarWeek(calendarAnchor);
      else renderCalendarMonth(calendarAnchor);
    }

    function renderCalendarWeek(anchorDate){
      const grid = document.getElementById('calendarGrid');
      const title = document.getElementById('periodTitle');
      grid.innerHTML = '';
      const s = startOfWeek(anchorDate);
      const e = endOfWeek(anchorDate);
      title.textContent = `${fmtYMD(s)} ~ ${fmtYMD(e)}`;
      const todayStr = toYYYYMMDD(new Date());
      for(let i=0;i<7;i++){
        const d = new Date(s); d.setDate(s.getDate()+i);
        const ds = fmtYMD(d);
        const cell = document.createElement('div');
        cell.className = 'calendar-cell';
        // highlight today's date
        if (ds === todayStr) {
          cell.classList.add('today');
        }
        const head = document.createElement('div');
        head.className = 'cell-date';
        head.textContent = ds;
        const holidayName = getHolidayLabel(ds);
        if (holidayName) {
          cell.classList.add('holiday');
          const hBadge = document.createElement('span');
          hBadge.className = 'holiday-label';
          hBadge.textContent = holidayName;
          head.appendChild(hBadge);
        }
        cell.appendChild(head);
        // Filter, sort, and display
        const dayAll = items.filter(it => it.date === ds);
        const dayFiltered = dayAll.filter(matchesWeeklyMonthly);
        const sorted = [...dayFiltered].sort(compareItems);
        const chips = document.createElement('div'); chips.className = 'calendar-chip';
        const total = document.createElement('span'); total.className = 'badge'; total.textContent = `총 ${dayFiltered.length}`;
        const done = document.createElement('span'); done.className = 'badge secondary'; done.textContent = `완료 ${dayFiltered.filter(x=>x.done).length}`;
        const open = document.createElement('span'); open.className = 'badge'; open.textContent = `미완료 ${dayFiltered.filter(x=>!x.done).length}`;
        chips.appendChild(total); chips.appendChild(done); chips.appendChild(open);
        cell.appendChild(chips);
        // Title area with scroll
        const titlesWrap = document.createElement('div');
        titlesWrap.className = 'calendar-titles';
        sorted.slice(0, WEEK_MAX_TITLES).forEach(it=>{
          const p = document.createElement('p');
          p.textContent = it.title;
          titlesWrap.appendChild(p);
        });
        cell.appendChild(titlesWrap);
        cell.addEventListener('click', ()=>{
          dateInput.value = ds;
          switchMode(VIEW_MODES.DAY);
        });
        grid.appendChild(cell);
      }
    }

    function renderCalendarMonth(anchorDate) {
      const grid = document.getElementById('calendarGrid');
      const title = document.getElementById('periodTitle');

      // 전체 셀 초기화
      grid.innerHTML = '';

      // 타이틀 표시: YYYY년 M월
      const y = anchorDate.getFullYear();
      const m = anchorDate.getMonth();
      title.textContent = `${y}년 ${m + 1}월`;

      // 1일을 기준으로 첫 주의 시작(일요일) 계산
      const first = new Date(y, m, 1);
      const firstWeekStart = startOfWeek(first);

      // 6주(42일) 그리드 생성
      const todayStr = toYYYYMMDD(new Date());
      for (let i = 0; i < 42; i++) {
        const d = new Date(firstWeekStart);
        d.setDate(firstWeekStart.getDate() + i);
        const ds = fmtYMD(d);

        // 셀 생성
        const cell = document.createElement('div');
        cell.className = 'calendar-cell';
        // highlight today's date
        if (ds === todayStr) {
          cell.classList.add('today');
        }
        // 월이 다르면 반투명 처리
        if (d.getMonth() !== m) cell.style.opacity = 0.5;

        // 날짜 헤더
        const head = document.createElement('div');
        head.className = 'cell-date';
        head.textContent = ds;
        const holidayName = getHolidayLabel(ds);
        if (holidayName) {
          cell.classList.add('holiday');
          const hBadge = document.createElement('span');
          hBadge.className = 'holiday-label';
          hBadge.textContent = holidayName;
          head.appendChild(hBadge);
        }
        cell.appendChild(head);

        // 해당 날짜의 업무 목록 (필터/검색/정렬)
        const dayAll = items.filter(it => it.date === ds);
        const dayFiltered = dayAll.filter(matchesWeeklyMonthly);
        const sorted = [...dayFiltered].sort(compareItems);

        // 뱃지 묶음
        const chips = document.createElement('div');
        chips.className = 'calendar-chip';

        // 총 업무 수 (filtered)
        const total = document.createElement('span');
        total.className = 'badge secondary';
        total.textContent = String(dayFiltered.length);
        chips.appendChild(total);

        // 미완료 업무 수 (filtered)
        const openCount = dayFiltered.filter(x => !x.done).length;
        const openBadge = document.createElement('span');
        openBadge.className = 'badge';
        openBadge.textContent = String(openCount);
        chips.appendChild(openBadge);

        // 가장 높은 중요도에 따른 별 표시 (filtered)
        let maxImportance = 0;
        dayFiltered.forEach(x => {
          const val = Number(x.importance) || 0;
          if (val > maxImportance) maxImportance = val;
        });
        const starBadge = document.createElement('span');
        starBadge.className = 'badge';
        starBadge.textContent = maxImportance > 0 ? '★'.repeat(maxImportance) : '-';
        chips.appendChild(starBadge);

        cell.appendChild(chips);

        // Title area with scroll
        const titlesWrap = document.createElement('div');
        titlesWrap.className = 'calendar-titles';
        sorted.slice(0, MONTH_MAX_TITLES).forEach(it => {
          const p = document.createElement('p');
          p.textContent = it.title;
          titlesWrap.appendChild(p);
        });
        cell.appendChild(titlesWrap);

        // 셀 클릭 시 해당 날짜를 일간 모드로 전환
        cell.addEventListener('click', () => {
          dateInput.value = ds;
          switchMode(VIEW_MODES.DAY);
        });

        grid.appendChild(cell);
      }
    }

    function switchMode(mode){
      viewMode = mode;
      const list = document.getElementById('list');
      const cal = document.getElementById('calendarView');
      if (mode === VIEW_MODES.DAY){
        cal.classList.add('hidden');
        list.classList.remove('hidden');
        render();
      } else {
        list.classList.add('hidden');
        cal.classList.remove('hidden');
        if (mode === VIEW_MODES.WEEK) renderCalendarWeek(calendarAnchor);
        else renderCalendarMonth(calendarAnchor);
      }
    }
    function shiftPeriod(delta){
      if (viewMode === VIEW_MODES.WEEK){
        calendarAnchor.setDate(calendarAnchor.getDate() + delta*7);
        renderCalendarWeek(calendarAnchor);
      } else if (viewMode === VIEW_MODES.MONTH){
        calendarAnchor.setMonth(calendarAnchor.getMonth() + delta);
        renderCalendarMonth(calendarAnchor);
      }
    }

    function calcDuration(start, end){
      if(!start || !end) return "";
      const [sh, sm] = start.split(":").map(Number);
      const [eh, em] = end.split(":").map(Number);
      const mins = (eh*60+em)-(sh*60+sm);
      if(isNaN(mins) || mins<0) return "";
      const hh = Math.floor(mins/60);
      const mm = mins%60;
      return (hh?`${hh}h `:"") + (mm?`${mm}m`:(hh?"":"0m"));
    }
    function updateDraftDuration(){
      durationBox.textContent = calcDuration(startInput.value, endInput.value) || "-";
    }
    startInput.addEventListener('input', updateDraftDuration);
    endInput.addEventListener('input', updateDraftDuration);

    function addItem(){
  const title = titleInput.value.trim();
  if(!title) return;
  let baseDate = (regDateInput && regDateInput.value) ? regDateInput.value : (dateInput.value || toYYYYMMDD());
  let repeatType = '';
  if (repeatWeekly && repeatWeekly.checked) {
    repeatType = 'weekly';
  } else if (repeatMonthly && repeatMonthly.checked) {
    repeatType = 'monthly';
  }
  // repeat end date (user-specified)
  const repeatUntil = (repeatEndInput && repeatEndInput.value) ? repeatEndInput.value : '';
  const datesList = [];
  if (repeatType === 'weekly') {
    const base = parseYMD(baseDate);
    // Use the day-of-week from the base date for weekly repeats
    const targetDow = base.getDay();
    // first occurrence of the target day-of-week on or after base date
    const diff = (targetDow - base.getDay() + 7) % 7;
    const first = new Date(base);
    first.setDate(base.getDate() + diff);
    let i = 0;
    while (true) {
      const dt = new Date(first);
      dt.setDate(first.getDate() + i * 7);
      const ds = fmtYMD(dt);
      if (repeatUntil && ds > repeatUntil) break;
      datesList.push(ds);
      i++;
      // if no repeatUntil specified, cap at 52 weeks
      if (!repeatUntil && i >= 52) break;
    }
  } else if (repeatType === 'monthly') {
    const base = parseYMD(baseDate);
    const baseDay = base.getDate();
    let i = 0;
    while (true) {
      const year = base.getFullYear();
      const month = base.getMonth() + i;
      const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
      const day = Math.min(baseDay, lastDayOfMonth);
      const dt = new Date(year, month, day);
      const ds = fmtYMD(dt);
      if (repeatUntil && ds > repeatUntil) break;
      datesList.push(ds);
      i++;
      // if no repeatUntil specified, cap at 12 months
      if (!repeatUntil && i >= 12) break;
    }
  } else {
    datesList.push(baseDate);
  }
  const rangeStart = datesList[0];
  const rangeEnd = datesList[datesList.length - 1];
  const groupId = uid();
  const created = [];
  for (const d of datesList) {
    const item = {
      id: uid(),
      date: d,
      title: title,
      memo: (memoInput.value || '').trim(),
      start: (startInput.value || '').trim(),
      end: (endInput.value || '').trim(),
      duration: calcDuration(startInput.value, endInput.value) || '',
      tags: (tagsInput.value || '').trim(),
      priority: Number(prioritySelect.value) || 999,
      importance: Number(importanceSelect.value) || 0,
      done: false,
      createdAt: Date.now(),
      groupId: groupId,
      rangeStart: rangeStart,
      rangeEnd: rangeEnd,
      repeat: repeatType,
      repeatDay: (repeatType === 'weekly' ? parseYMD(baseDate).getDay() : ''),
      repeatUntil: repeatUntil || rangeEnd,
    };
    created.push(item);
  }
  items = [...created, ...items];
  save(items);
  // close modal upon successful creation
  try { closeAddModal(); } catch(e) {}
  // reset
  titleInput.value = '';
  // Clear registration date after creating a new item
  if (regDateInput) regDateInput.value = '';
  if (repeatWeekly) repeatWeekly.checked = false;
  if (repeatMonthly) repeatMonthly.checked = false;
  if(repeatEndInput) repeatEndInput.value = '';
  if(startDateInput) startDateInput.value = dateInput.value;
  if(endDateInput) endDateInput.value = '';
  memoInput.value = '';
  memoInput.style.height = '40px';
  startInput.value = '';
  endInput.value = '';
  durationBox.textContent = '-';
  tagsInput.value = '';
  prioritySelect.value = '3';
  importanceSelect.value = '3';
  render();
}

    // removed top addBtn listeneadd
    addBtn2.addEventListener('click', ()=> {
      if (editingGid) saveEdit();
      else addItem();
    });
    function saveEdit(){
  if (!editingGid) return;
  const title = titleInput.value.trim();
  if(!title) return;
  let baseDate = (regDateInput && regDateInput.value) ? regDateInput.value : (dateInput.value || toYYYYMMDD());
  let repeatType = '';
  if (repeatWeekly && repeatWeekly.checked) {
    repeatType = 'weekly';
  } else if (repeatMonthly && repeatMonthly.checked) {
    repeatType = 'monthly';
  }
  // repeat end date (user-specified)
  const repeatUntil = (repeatEndInput && repeatEndInput.value) ? repeatEndInput.value : '';
  const datesList = [];
  if (repeatType === 'weekly') {
    const base = parseYMD(baseDate);
    // Use the day-of-week from the base date for weekly repeats
    const targetDow = base.getDay();
    const diff = (targetDow - base.getDay() + 7) % 7;
    const first = new Date(base);
    first.setDate(base.getDate() + diff);
    let i = 0;
    while (true) {
      const dt = new Date(first);
      dt.setDate(first.getDate() + i * 7);
      const ds = fmtYMD(dt);
      if (repeatUntil && ds > repeatUntil) break;
      datesList.push(ds);
      i++;
      if (!repeatUntil && i >= 52) break;
    }
  } else if (repeatType === 'monthly') {
    const base = parseYMD(baseDate);
    const baseDay = base.getDate();
    let i = 0;
    while (true) {
      const year = base.getFullYear();
      const month = base.getMonth() + i;
      const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
      const day = Math.min(baseDay, lastDayOfMonth);
      const dt = new Date(year, month, day);
      const ds = fmtYMD(dt);
      if (repeatUntil && ds > repeatUntil) break;
      datesList.push(ds);
      i++;
      if (!repeatUntil && i >= 12) break;
    }
  } else {
    datesList.push(baseDate);
  }
  const rangeStart = datesList[0];
  const rangeEnd = datesList[datesList.length - 1];
  const repStart = (startInput.value || '').trim();
  const repEnd = (endInput.value || '').trim();
  const dur = calcDuration(repStart, repEnd) || '';
  const memo = (memoInput.value || '').trim();
  const tags = (tagsInput.value || '').trim();
  const priority = Number(prioritySelect.value) || 999;
  const importance = Number(importanceSelect.value) || 0;
  const old = items.filter(x => (x.groupId || x.id) === editingGid);
  const keep = items.filter(x => (x.groupId || x.id) !== editingGid);
  const newOnes = [];
  for (const d of datesList) {
    newOnes.push({
      id: uid(),
      date: d,
      title: title,
      memo: memo,
      start: repStart,
      end: repEnd,
      duration: dur,
      tags: tags,
      priority: priority,
      importance: importance,
      done: false,
      createdAt: Date.now(),
      groupId: editingGid,
      rangeStart: rangeStart,
      rangeEnd: rangeEnd,
      repeat: repeatType,
      repeatDay: (repeatType === 'weekly' ? parseYMD(baseDate).getDay() : ''),
      repeatUntil: repeatUntil || rangeEnd,
    });
  }
  items = [...newOnes, ...keep];
  save(items);
  editingGid = null;
  addBtn2.textContent = '등록';
  document.getElementById('modalTitle').textContent = '업무 등록';
  // Reset date inputs when closing after edit so they don't persist on next add
  try{
    if (regDateInput) regDateInput.value = '';
    if (repeatEndInput) repeatEndInput.value = '';
    if (repeatWeekly) repeatWeekly.checked = false;
    if (repeatMonthly) repeatMonthly.checked = false;
  } catch(e){}
  closeAddModal();
  render();
}
    tagsInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') addItem(); });

    // Auto-expand memoInput height (cap at 6 lines; then show vertical scroll)
const memoInputEl = document.getElementById('memoInput');
if (memoInputEl) {
  const maxLines = 6;
  const lineHeightPx = parseInt(window.getComputedStyle(memoInputEl).lineHeight) || 20;
  const minHeightPx = 40;
  const maxHeightPx = Math.max(minHeightPx, lineHeightPx * maxLines);

  const autoGrow = () => {
    memoInputEl.style.height = 'auto';
    const next = Math.min(memoInputEl.scrollHeight, maxHeightPx);
    memoInputEl.style.height = next + 'px';
    memoInputEl.style.overflowY = (memoInputEl.scrollHeight > maxHeightPx) ? 'auto' : 'hidden';
  };

  memoInputEl.addEventListener('input', autoGrow);
  // initial sync on load
  autoGrow();
}

    function csvEscape(s){ return ('"'+ String(s).replaceAll('"','""') +'"'); }

    function saveToCSV(){
      const header = ["id","groupId","date","rangeStart","rangeEnd","repeat","repeatDay","repeatUntil","title","memo","start","end","duration","tags","priority","importance","done","createdAt"];
      const rows = items.map(it => header.map(h => csvEscape(it[h] ?? "")).join(","));
      const csv = [header.join(","), ...rows].join("\n");
      const blob = new Blob(["\ufeff"+csv], {type: "text/csv;charset=utf-8;"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `worklog_${toYYYYMMDD()}.csv`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    if (saveCsvBtn) saveCsvBtn.addEventListener('click', saveToCSV);
    if (saveCsvBtn2) saveCsvBtn2.addEventListener('click', saveToCSV);

    // Expose for other handlers (optional)
    try { window._saveToCSV = saveToCSV; } catch(e) {}

    // Wire toolbar import/export buttons
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    if (importBtn) importBtn.addEventListener('click', ()=> fileInput && fileInput.click());
    if (exportBtn) exportBtn.addEventListener('click', ()=> saveToCSV());

    function parseCsvLine(line){
      const cols=[]; let cur=""; let inQ=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch === '"'){
          if(inQ && line[i+1] === '"'){ cur+='"'; i++; }
          else inQ = !inQ;
        }else if(ch === ',' && !inQ){
          cols.push(cur); cur="";
        }else cur += ch;
      }
      cols.push(cur);
      return cols;
    }

    function loadFromCSV(file){
      const reader = new FileReader();
      reader.onload = (e)=>{
        const text = String(e.target?.result || "");
        const lines = text.split(/\r?\n/).filter(Boolean);
        if(lines.length === 0) return;
        const keys = lines[0].split(",").map(h => h.replaceAll('"','').trim());
        const parsed = lines.slice(1).map(line => {
          const cols = parseCsvLine(line);
          const obj = {};
          keys.forEach((k,i)=> obj[k] = cols[i] ? cols[i].replaceAll('""','"').replace(/^"|"$/g,"") : "");
          obj.priority = Number(obj.priority || 999);
          obj.importance = Number(obj.importance || 0);
          obj.done = String(obj.done).toLowerCase() === "true";
          obj.createdAt = Number(obj.createdAt || Date.now());
          obj.groupId = obj.groupId || uid();
          obj.rangeStart = obj.rangeStart || obj.date || "";
          obj.rangeEnd = obj.rangeEnd || obj.date || "";
          // normalize repeatDay to number or blank
          if (obj.hasOwnProperty('repeatDay')) {
            if (obj.repeatDay === undefined || obj.repeatDay === '') {
              obj.repeatDay = '';
            } else {
              const rd = Number(obj.repeatDay);
              obj.repeatDay = isNaN(rd) ? '' : rd;
            }
          }
          // ensure repeatUntil property exists
          if (!obj.hasOwnProperty('repeatUntil') || obj.repeatUntil === undefined) {
            obj.repeatUntil = '';
          }
          return obj;
        });
        const ids = new Set(items.map(p => p.id));
        const merged = parsed.map(p => ({...p, id: ids.has(p.id) ? uid() : p.id}));
        items = [...items, ...merged];
        save(items);
        render();
      };
      reader.readAsText(file, "utf-8");
    }

    if (loadCsvBtn) loadCsvBtn.addEventListener('click', ()=> fileInput && fileInput.click());
    if (loadCsvBtn2) loadCsvBtn2.addEventListener('click', ()=> fileInput && fileInput.click());
    if (fileInput) fileInput.addEventListener('change', (e)=>{
      const f = e.target.files?.[0];
      if(f) loadFromCSV(f);
      fileInput.value = "";
    });

    function render(){
      const date = dateInput.value;
      const filter = filterSelect.value;
      const q = (queryInput.value || "").toLowerCase().trim();
      const isGlobalSearch = !!q;

      // 오늘 선택된 날짜가 공휴일이면 상단에 뱃지로 표시
      // (검색 중에는 여러 날짜가 섞이므로 뱃지는 숨김)
      if (todayHolidayEl) {
        if (isGlobalSearch) {
          todayHolidayEl.style.display = 'none';
        } else {
          const holidayName = getHolidayLabel(date);
          if (holidayName) {
            todayHolidayEl.textContent = holidayName;
            todayHolidayEl.style.display = 'inline-flex';
          } else {
            todayHolidayEl.style.display = 'none';
          }
        }
      }

      // 1) step: item-level filter by date (only when not searching) + query
      // - 검색어 없음: 선택된 날짜만
      // - 검색어 있음: 전체 날짜에서 검색
      const dateQueryFiltered = items.filter(it => {
        const d = it.date || '';
        const currentDate = dateInput.value || toYYYYMMDD();

        if (!isGlobalSearch) {
          if (d !== currentDate) return false;
        }

        if (!q) return true;
        const hay = `${it.title || ''} ${it.memo || ''} ${it.tags || ''}`.toLowerCase();
        return hay.includes(q);
      });

      // 2) build map of all items by groupId (use all items, not just filtered)
      const allByGroup = new Map();
      for (const it of items) {
        const gid = it.groupId || it.id;
        if (!allByGroup.has(gid)) allByGroup.set(gid, []);
        allByGroup.get(gid).push(it);
      }

      // 3) candidate group ids (those having at least one item inside the dateQueryFiltered result)
      const candidateGroupIds = Array.from(new Set(dateQueryFiltered.map(it => it.groupId || it.id)));

      // 4) construct group view models
      const groups = candidateGroupIds.map(gid => {
        const groupItems = allByGroup.get(gid) || [];
        // derive representative and aggregates
        const anyItem = groupItems[0] || {};
        const title = anyItem.title || "";
        const memo = anyItem.memo || "";
        const priority = Number(anyItem.priority ?? 999);
        const importance = Number(anyItem.importance ?? 0);
        const createdAt = Math.max(...groupItems.map(x => Number(x.createdAt || 0)), 0);

        const startTimes = groupItems.map(x => x.start || "").filter(Boolean).sort();
        const repStart = startTimes[0] || anyItem.start || "";
        const endTimes = groupItems.map(x => x.end || "").filter(Boolean).sort();
        const repEnd = endTimes[endTimes.length-1] || anyItem.end || "";
        const repDuration = anyItem.duration || "";

        const dates = groupItems.map(x => x.date || "").filter(Boolean).sort();
        const minDate = (anyItem.rangeStart || dates[0] || "");
        const maxDate = (anyItem.rangeEnd || dates[dates.length-1] || minDate);

        // Determine completion based on items for the current date only
        const currentDateVal = dateInput.value || toYYYYMMDD();
        const itemsForDate = groupItems.filter(x => x.date === currentDateVal);
        const allDone = itemsForDate.length > 0 ? itemsForDate.every(x => !!x.done) : false;
        const someDone = itemsForDate.some(x => !!x.done);

        return {
          gid, title, memo, priority, importance, createdAt,
          repStart, repEnd, repDuration,
          minDate, maxDate,
          allDone, someDone,
          items: groupItems
        };
      });

      // 5) apply STATUS filter at group level
      const groupFiltered = groups.filter(g => {
        if (filter === 'open') return !g.allDone;
        if (filter === 'done') return g.allDone;
        return true; // 'all'
      });

      // 6) sort
      groupFiltered.sort((a,b) => {
        if (a.allDone !== b.allDone) return Number(a.allDone) - Number(b.allDone); // not-done first
        const ap = Number(a.priority ?? 999), bp = Number(b.priority ?? 999);
        if (ap !== bp) return ap - bp;
        const ai = Number(a.importance ?? 0), bi = Number(b.importance ?? 0);
        if (ai !== bi) return bi - ai;
        return (a.repStart||"").localeCompare(b.repStart||"") || (b.createdAt - a.createdAt);
      });

      // 7) stats by groups
      const totalGroups = groups.length;
      const doneGroups = groups.filter(g => g.allDone).length;
      statTotal.textContent = `총 ${totalGroups}`;
      statDone.textContent = `완료 ${doneGroups}`;
      statOpen.textContent = `미완료 ${totalGroups - doneGroups}`;

      // 8) render
      listEl.innerHTML = "";
      if (groupFiltered.length === 0) {
        const empty = document.createElement('div');
        empty.className = "card empty";
        empty.textContent = '해당 조건의 업무일지가 없습니다. 상단에서 "등록"을 눌러 추가해줘.';
        listEl.appendChild(empty);
        return;
      }

      for (const g of groupFiltered) {
        const card = document.createElement('div');
        card.className = "card item" + (g.allDone ? " done" : "");

        const row = document.createElement('div');
        row.style.display = "flex";
        row.style.gap = "12px";
        row.style.alignItems = "flex-start";

        const left = document.createElement('div');
        left.className = "left";

        const titleRow = document.createElement('div');
        titleRow.style.display = "flex";
        titleRow.style.gap = "8px";
        titleRow.style.alignItems = "center";

        const state = document.createElement('span');
        state.className = "badge " + (g.allDone ? "secondary" : "");
        state.textContent = g.allDone ? "완료" : "진행";
        titleRow.appendChild(state);

        const h3 = document.createElement('h3');
        h3.textContent = g.title;
        h3.style.margin = "0";
        h3.style.fontSize = "17px";
        h3.style.fontWeight = "600";
        titleRow.appendChild(h3);

        left.appendChild(titleRow);

        if (g.memo) {
          const p = document.createElement('p');
          p.textContent = g.memo;
          p.style.whiteSpace = "pre-wrap";
          p.style.margin = "6px 0 0 0";
          p.style.color = "var(--muted)";
          p.style.fontSize = "14px";
          left.appendChild(p);
        }

        const chips = document.createElement('div');
        chips.className = "chips muted";

        // date range chip
        const dchip = document.createElement('span');
        dchip.className = "badge";
        dchip.textContent = g.minDate === g.maxDate ? (g.minDate || "-") : `${g.minDate} ~ ${g.maxDate}`;
        chips.appendChild(dchip);

        // time chip (displayed on a new line)
        if (g.repStart || g.repEnd || g.repDuration) {
          const timeRow = document.createElement('div');
          timeRow.style.marginTop = "4px";
          const tchip = document.createElement('span');
          tchip.className = "badge";
          tchip.style.fontSize = "16px";
          tchip.textContent = `${g.repStart || "-"} ~ ${g.repEnd || "-"} (${g.repDuration || "-"})`;
          timeRow.appendChild(tchip);
          chips.appendChild(timeRow);
        }

        // priority & importance
        const pchip = document.createElement('span');
        pchip.className = "badge";
        pchip.textContent = `P${g.priority ?? "-"}`;
        chips.appendChild(pchip);

        const ichip = document.createElement('span');
        ichip.className = "badge";
        ichip.textContent = (g.importance ? "★".repeat(Number(g.importance)) : "-");
        chips.appendChild(ichip);

        // created at
        const rchip = document.createElement('span');
        rchip.className = "badge secondary";
        try {
          const d = new Date(Number(g.createdAt));
          if (!isNaN(d.getTime())) {
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            rchip.textContent = `등록 ${hh}:${mm}`;
          }
        } catch(e){}
        chips.appendChild(rchip);

        // tags (from any representative item)
        const repTags = g.items.find(x => x.tags)?.tags || "";
        if (repTags) {
          (repTags.split(",")||[]).forEach(tt => {
            const tag = document.createElement('span');
            tag.className = "badge";
            tag.textContent = "#" + tt.trim();
            chips.appendChild(tag);
          });
        }
        left.appendChild(chips);

        const right = document.createElement('div');
        right.className = "right-actions";

        const doneBtn = document.createElement('button');
        doneBtn.textContent = "완료";
        doneBtn.addEventListener('click', ()=>{
          // Toggle completion only for tasks matching the current date
          const currentDateVal = dateInput.value || toYYYYMMDD();
          const newState = !g.allDone;
          for (const x of g.items) {
            if (x.date === currentDateVal) {
              x.done = newState;
            }
          }
          save(items);
          render();
        });
        right.appendChild(doneBtn);

        const delBtn = document.createElement('button');
        delBtn.textContent = "삭제";
        delBtn.className = "danger";
        delBtn.addEventListener('click', ()=>{
          const count = g.items?.length || 1;
          const msg = count > 1
            ? `이 업무는 ${count}개 날짜 항목으로 묶여 있습니다.\n정말 한 번에 모두 삭제할까요? (되돌릴 수 없음)`
            : "정말 삭제할까요? (되돌릴 수 없음)";
          if (!window.confirm(msg)) return;
          const setId = new Set(g.items.map(x => x.id));
          items = items.filter(x => !setId.has(x.id));
          save(items);
          render();
        });
        right.appendChild(delBtn);
        const editBtn = document.createElement('button');
        editBtn.textContent = "수정";
        editBtn.className = "ghost";
        editBtn.addEventListener('click', ()=> openAddModal(g));
        right.appendChild(editBtn);

        row.appendChild(left);
        row.appendChild(right);
        card.appendChild(row);
        listEl.appendChild(card);
      }
    }

  // 검색/필터 변경 시 현재 보기에 맞게 다시 렌더링
  queryInput.addEventListener('input', renderCurrent);
  filterSelect.addEventListener('change', renderCurrent);

  // dateInput 변경 시 바로 렌더링 (일간 전용)
  dateInput.addEventListener('change', render);
  dateInput.addEventListener('input', render);



    // ========== Calendar/list view switching buttons wiring ==========
    const viewDayBtn = document.getElementById('viewDayBtn');
    const viewWeekBtn = document.getElementById('viewWeekBtn');
    const viewMonthBtn = document.getElementById('viewMonthBtn');
    if (viewDayBtn) viewDayBtn.addEventListener('click', ()=> switchMode(VIEW_MODES.DAY));
    if (viewWeekBtn) viewWeekBtn.addEventListener('click', ()=> switchMode(VIEW_MODES.WEEK));
    if (viewMonthBtn) viewMonthBtn.addEventListener('click', ()=> switchMode(VIEW_MODES.MONTH));
    const prevPeriodBtn = document.getElementById('prevPeriodBtn');
    const nextPeriodBtn = document.getElementById('nextPeriodBtn');
    const todayBtn = document.getElementById('todayBtn');

    if (prevPeriodBtn) prevPeriodBtn.addEventListener('click', () => {
      if (viewMode === VIEW_MODES.DAY) {
        try {
          const cur = dateInput.value || toYYYYMMDD();
          const d = new Date(cur);
          d.setDate(d.getDate() - 1);
          dateInput.value = toYYYYMMDD(d);
        } catch (e) {}
        render();
      } else {
        shiftPeriod(-1);
      }
    });

    if (todayBtn) todayBtn.addEventListener('click', () => {
      if (viewMode === VIEW_MODES.DAY) {
        try { dateInput.value = toYYYYMMDD(new Date()); } catch (e) {}
        render();
      } else {
        calendarAnchor = new Date();
        (viewMode === VIEW_MODES.WEEK ? renderCalendarWeek : renderCalendarMonth)(calendarAnchor);
      }
    });

    if (nextPeriodBtn) nextPeriodBtn.addEventListener('click', () => {
      if (viewMode === VIEW_MODES.DAY) {
        try {
          const cur = dateInput.value || toYYYYMMDD();
          const d = new Date(cur);
          d.setDate(d.getDate() + 1);
          dateInput.value = toYYYYMMDD(d);
        } catch (e) {}
        render();
      } else {
        shiftPeriod(1);
      }
    });
    render();
  })();
  </script>
  <script>
    // 단축키: Alt+N (새 업무 등록 버튼을 열기 위한 단축키)
    // Alt 키와 'N' 키를 함께 누르면 '새 업무 등록' 모달을 여는 버튼을 클릭합니다.
    document.addEventListener('keydown', function (event) {
      // Alt 키와 N 키 확인 (대소문자 무시)
      if (event.altKey && (event.key === 'n' || event.key === 'N')) {
        // 기본 Alt+N 동작 방지
        event.preventDefault();
        // 새 업무 등록 버튼 선택 (id="openModalBtn")
        const newTaskBtn = document.getElementById('openModalBtn');
        if (newTaskBtn) {
          // 버튼 클릭으로 모달 열기
          newTaskBtn.click();
        }
      }
    });
  </script>

</body>
</html>
